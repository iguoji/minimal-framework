## 注解

系统将扫描所有类及其公开方法，目前主要针对路由功能

语法：`#[注解类名(参数1, 参数2)]`

也可以理解为：`#[标签(参数1, 参数2)]`

如果想使用框架的注解模块，则使用 `标签`，原因是不想 `use` 注解类或是指定注解类的命名空间

如果想使用用户的注解模块，则使用 `注解类名`，因为通过反射得到的注解类名将会自动附带用户当前的命名空间

因此

首先得判断用户的命名空间下有没有该注解类，并且是否真的为注解类

如果真的有，则调用用户的注解类，反之去掉替换命名空间为框架的命名空间，再进行调用

### 路由 Route

`#[Route(['get', 'post'], '/hello/world')]`

仅类的方法有效

### 域名 Domain

`#[Domain('www.baidu.com', '*.baidu.com', '*.dev.baidu.com')]`

针对HTTP请求限制域名访问，类和方法都有效，方法将覆盖类的设置

### 中间件 Middleware

`#[Middleware(App\Middleware\M1::class, ...)]`

当该方法被调用时，提前调用中间件处理，类和方法都有效，方法将覆盖类的设置


### 思路


#### 2020-09-24

语法：

没参数的：`#[注解类名]`

有参数的：`#[注解类名(构造函数参数1, 构造函数参数2)]`

场景：

一、给控制器下的方法设置路由

二、给整个控制器或单个方法设置中间件

三、给整个控制器或单个方法设置可访问的域名

四、给某个类绑定到容器

类型：

一、功能型：通常用于程序初始化时的一些操作，例如添加路由、容器绑定

二、事件型：针对`Http请求`，在路由回调每次被执行前先行执行，例如中间件

三、参数型：本身并无功能，通常保存于上下文中方便其他注解类使用

例子：

```php
#[Domain(['a.com', 'b.com'])]
#[Middleware([Auth::class])]
#[Unknown(1, '2', false, null)]
class Controller
{
    #[Route('/', ['GET'])]
    #[Middleware]
    public function welcome(){}

    #[Route('/index', ['GET', 'POST'])]
    public function index(){}
}
```

上面这个例子最终想要结果：

1. 给 `welcome` 注册了路由，且不使用任何中间件

2. 给 `index` 注册了路由，且当每次 `Http请求` 到达时都将使用 `Auth::class` 中间件先行处理

然后解析框架处理的流程：

1. 程序启动 -> 递归扫描`basePath`文件夹下所有文件 -> 循环解析[**类|函数**]的注解

2. 首先解析**类**的注解

    2.1 `Domain(['a.com', 'b.com'])`

    `Domain`，属于参数型，因为位于类中，所以其域名列表将保存于全局上下文提供给 `Route` 注解类使用

    2.2 `Middleware([Auth::class])`

    `Middleware`，属于事件型，因为位于类中，所以其中间件将应用于该控制器下所有方法

    2.3 `Unknown(1, '2', false, null)`

    `Unknown` 不存在，将会被以 `unknown` 为键值，将其值 `[1, '2', false, null]` 保存在全局上下文中

3. 然后解析**方法**的注解

    3.1 `welcome` 方法

    3.1.1 `Route('/', ['GET'])`，属于功能型，将会为该方法注册一个路由

    2.1.2 `Middleware`，属于事件型，将会覆盖类中定义的相同注解，在此表示该方法不使用任何中间件

    3.2 `index` 方法

    3.2.1 `Route('/index', ['GET', 'POST'])`，属于功能型，将会为该方法注册一个路由

2. 通过容器创建注解类的对象 = Container->make(注解类, 注解参数) -> 得到注解实例，以下简称注解

3. 注解 -> 构造函数接收参数，进行初始化准备 -> `handle` 函数进行功能设置，第一个参数为（array $context）

4.






#### 2020-09-23


每一个 `Attribute` 对应的是一个注解类名，以及其构造函数的参数

方式一，函数内部完成功能

以路由为例

用户编写注解类，在其构造函数中，解析参数，并添加路由 `Framework\Route::addRoute(...)`

以中间件为例

用户编写注解类，在其构造函数中，解析参数，并监听事件 `Framework\Event::on('Namespace\MyController:before')`

方式二，函数返回数据结构

以路由为例

用户编写注解类，在其构造函数中，解析参数，并返回结构 `['domain']`

以中间件为例

用户编写注解类，在其构造函数中，解析参数，并返回结构 `['middlewares' => ]`

```php
[
    'class'     =>  [
        'attr1'     =>  1,
        'attr2'     =>  false,
        'attr3'     =>  null,
        'attr4'     =>  fn() => true,
        'attr5'     =>  new StdClass()
    ],
    'methods'   =>  [
        'save'      =>  ['a', 'b', 'c'],
        'read'      =>  [1, 2, 3, 4],
        'edit'      =>  [false, new StdClass()],
        'remove'    =>  [null],
        'all'       =>  [true, true, true]
    ]
]
```